// backend/src/models/Preparation.js - VERSION CORRIG√âE POUR RAPPORT
const mongoose = require('mongoose');
const { PREPARATION_STATUS, PREPARATION_STEPS, DEFAULT_STEPS, TIME_LIMITS } = require('../utils/constants');

// ===== SOUS-SCH√âMAS =====

// Sch√©ma pour les √©tapes de pr√©paration
const preparationStepSchema = new mongoose.Schema({
  step: {
    type: String,
    enum: Object.values(PREPARATION_STEPS),
    required: true
  },
  completed: {
    type: Boolean,
    default: false
  },
  completedAt: Date,
  duration: {
    type: Number, // en minutes
    min: 0
  },
  notes: {
    type: String,
    maxlength: 500,
    default: ''
  },
  photos: [{
    url: {
      type: String,
      required: true
    },
    description: {
      type: String,
      default: ''
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }]
}, { _id: true });

// ‚úÖ SCH√âMA V√âHICULE UNIFI√â (remplace vehicleInfo ET vehicleData)
const vehicleDataSchema = new mongoose.Schema({
  licensePlate: {
    type: String,
    required: true,
    uppercase: true,
    trim: true
  },
  brand: {
    type: String,
    required: false,
    trim: true,
    default: 'N/A' // ‚úÖ Valeur par d√©faut pour √©viter les cha√Ænes vides
  },
  model: {
    type: String,
    required: true,
    trim: true,
    default: 'V√©hicule'
  },
  vehicleType: {
    type: String,
    enum: ['particulier', 'utilitaire'],
    required: true,
    default: 'particulier'
  },
  year: {
    type: Number,
    min: 1990,
    max: new Date().getFullYear() + 2
  },
  fuelType: {
    type: String,
    enum: ['essence', 'diesel', 'electrique', 'hybride'],
    default: 'essence'
  },
  color: {
    type: String,
    trim: true,
    maxlength: 30,
    default: ''
  },
  condition: {
    type: String,
    enum: ['excellent', 'good', 'fair', 'poor'],
    default: 'good'
  }
}, { _id: false });

// Sch√©ma pour les incidents
const issueSchema = new mongoose.Schema({
  type: {
    type: String,
    enum: ['damage', 'cleanliness', 'missing_item', 'mechanical', 'other'],
    required: true
  },
  description: {
    type: String,
    required: true,
    trim: true,
    maxlength: 500
  },
  severity: {
    type: String,
    enum: ['low', 'medium', 'high'],
    default: 'medium'
  },
  reportedAt: {
    type: Date,
    default: Date.now
  },
  photos: [String],
  resolved: {
    type: Boolean,
    default: false
  },
  resolvedAt: Date,
  resolvedBy: String
}, { _id: true });

// ===== SCH√âMA PRINCIPAL UNIFI√â =====

const preparationSchema = new mongoose.Schema({
  // R√©f√©rence vers l'utilisateur (pr√©parateur)
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Le pr√©parateur est requis'],
    index: true
  },

  // ‚úÖ COMPATIBILIT√â : Ancien champ pr√©parateur (sera supprim√© apr√®s migration)
  preparateur: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },

  // R√©f√©rence vers l'agence
  agency: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Agency',
    required: [true, 'L\'agence est requise'],
    index: true
  },

  // R√©f√©rence vers le v√©hicule (optionnelle)
  vehicle: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vehicle',
    required: false
  },

  // ‚úÖ DONN√âES V√âHICULE UNIFI√âES (source unique de v√©rit√©)
  vehicleData: {
    type: vehicleDataSchema,
    required: true
  },

  // ‚úÖ COMPATIBILIT√â : Ancien champ vehicleInfo (DEPRECATED - sera supprim√©)
  vehicleInfo: {
    type: mongoose.Schema.Types.Mixed,
    required: false
  },

  // Statut de la pr√©paration
  status: {
    type: String,
    enum: Object.values(PREPARATION_STATUS),
    default: PREPARATION_STATUS.PENDING,
    index: true
  },

  // Priorit√©
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal',
    index: true
  },

  // Qui a cr√©√© cette pr√©paration
  createdBy: {
    id: {
      type: mongoose.Schema.Types.ObjectId,
      required: false // ‚úÖ Optionnel pour anciennes pr√©parations
    },
    name: {
      type: String,
      required: false
    },
    email: {
      type: String,
      required: false
    },
    role: {
      type: String,
      enum: ['admin', 'preparateur'],
      required: false
    }
  },

  // √âtapes de pr√©paration
  steps: [preparationStepSchema],

  // Temps de d√©but
  startTime: {
    type: Date,
    default: Date.now
  },

  // Temps de fin
  endTime: Date,

  // Dur√©e totale en minutes
  totalTime: {
    type: Number,
    min: 0
  },

  // Dur√©e actuelle en minutes
  currentDuration: {
    type: Number,
    default: 0,
    min: 0
  },

  // Progression en pourcentage
  progress: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },

  // Dans les temps
  isOnTime: Boolean,

  // Notes g√©n√©rales
  notes: {
    type: String,
    maxlength: 1000,
    default: ''
  },

  // Incidents signal√©s
  issues: [issueSchema],

  // Historique des agences
  agencyHistory: [{
    agency: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Agency'
    },
    changedAt: {
      type: Date,
      default: Date.now
    },
    reason: String
  }]

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// ===== INDEXES =====
preparationSchema.index({ user: 1, status: 1 });
preparationSchema.index({ agency: 1, status: 1 });
preparationSchema.index({ 'vehicleData.licensePlate': 1 });
preparationSchema.index({ createdAt: -1 });
preparationSchema.index({ status: 1, createdAt: -1 });

// ‚ö†Ô∏è INDEX SP√âCIAL POUR RAPPORT : Performance sur les √©tapes
preparationSchema.index({ 'steps.step': 1 });
preparationSchema.index({ agency: 1, createdAt: -1 });

// ===== MIDDLEWARE DE MIGRATION AUTOMATIQUE =====

// ‚úÖ AVANT SAUVEGARDE : Migrer vehicleInfo vers vehicleData
preparationSchema.pre('save', function(next) {
  try {
    // ‚ö†Ô∏è VALIDATION CRITIQUE : V√©rifier que les ObjectIds sont valides
    if (this.user && !mongoose.Types.ObjectId.isValid(this.user)) {
      console.error(`‚ùå ObjectId invalide pour user: ${this.user}`);
      return next(new Error(`Invalid user ObjectId: ${this.user}`));
    }
    if (this.agency && !mongoose.Types.ObjectId.isValid(this.agency)) {
      console.error(`‚ùå ObjectId invalide pour agency: ${this.agency}`);
      return next(new Error(`Invalid agency ObjectId: ${this.agency}`));
    }
    if (this.vehicle && !mongoose.Types.ObjectId.isValid(this.vehicle)) {
      console.error(`‚ùå ObjectId invalide pour vehicle: ${this.vehicle}`);
      return next(new Error(`Invalid vehicle ObjectId: ${this.vehicle}`));
    }

    // Si vehicleInfo existe mais pas vehicleData, migrer automatiquement
    if (this.vehicleInfo && !this.vehicleData) {
      console.log(`üîÑ Migration automatique vehicleInfo -> vehicleData pour ${this._id}`);
      
      this.vehicleData = {
        licensePlate: this.vehicleInfo.licensePlate || 'N/A',
        brand: this.vehicleInfo.brand || 'N/A',
        model: this.vehicleInfo.model || 'V√©hicule',
        vehicleType: this.vehicleInfo.vehicleType || 'particulier',
        year: this.vehicleInfo.year,
        fuelType: this.vehicleInfo.fuelType || 'essence',
        color: this.vehicleInfo.color || '',
        condition: this.vehicleInfo.condition || 'good'
      };
    }

    // Assurer que vehicleData est valide
    if (this.vehicleData) {
      if (!this.vehicleData.brand || this.vehicleData.brand.trim() === '') {
        this.vehicleData.brand = 'N/A';
      }
      if (!this.vehicleData.model || this.vehicleData.model.trim() === '') {
        this.vehicleData.model = 'V√©hicule';
      }
      if (!this.vehicleData.vehicleType) {
        this.vehicleData.vehicleType = 'particulier';
      }
      
      // ‚ö†Ô∏è IMPORTANT : S'assurer que licensePlate n'est pas un ObjectId
      if (this.vehicleData.licensePlate) {
        // Si c'est un ObjectId, utiliser une valeur par d√©faut
        if (mongoose.Types.ObjectId.isValid(this.vehicleData.licensePlate) && 
            this.vehicleData.licensePlate.length === 24) {
          console.warn(`‚ö†Ô∏è licensePlate semble √™tre un ObjectId: ${this.vehicleData.licensePlate}`);
          this.vehicleData.licensePlate = 'PLAQUE-INCONNUE';
        }
      }
    }

    // Synchroniser preparateur avec user pour compatibilit√©
    if (this.user && !this.preparateur) {
      this.preparateur = this.user;
    }

    next();
  } catch (error) {
    console.error('‚ùå Erreur middleware pre-save:', error);
    next(error);
  }
});

// ‚úÖ APR√àS SAUVEGARDE : Synchroniser avec v√©hicule li√© si disponible
preparationSchema.post('save', async function(doc) {
  if (doc.vehicle && doc.vehicleData && (!doc.vehicleData.brand || doc.vehicleData.brand === 'N/A')) {
    try {
      const Vehicle = mongoose.model('Vehicle');
      const vehicle = await Vehicle.findById(doc.vehicle);
      
      if (vehicle && vehicle.brand && vehicle.brand.trim() !== '') {
        doc.vehicleData.brand = vehicle.brand;
        await doc.save({ validateBeforeSave: false });
        console.log(`‚úÖ Synchronis√© brand depuis v√©hicule: ${vehicle.brand}`);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur synchronisation vehicleData:', error.message);
    }
  }
});

// ===== M√âTHODES D'INSTANCE =====

// Obtenir le nom complet du v√©hicule (compatible pour rapport)
preparationSchema.methods.getVehicleFullName = function() {
  // ‚úÖ RAPPORT : Priorit√© vehicleData puis vehicleInfo puis populate
  let brand = 'N/A', model = 'V√©hicule', licensePlate = 'INCONNUE';
  
  if (this.vehicleData) {
    brand = this.vehicleData.brand || 'N/A';
    model = this.vehicleData.model || 'V√©hicule';
    licensePlate = this.vehicleData.licensePlate || 'INCONNUE';
  } else if (this.vehicleInfo) {
    brand = this.vehicleInfo.brand || 'N/A';
    model = this.vehicleInfo.model || 'V√©hicule';
    licensePlate = this.vehicleInfo.licensePlate || 'INCONNUE';
  } else if (this.vehicle && this.vehicle.brand) {
    // Si populate
    brand = this.vehicle.brand;
    model = this.vehicle.model || 'V√©hicule';
    licensePlate = this.vehicle.licensePlate || 'INCONNUE';
  }
  
  const fullName = brand && brand !== 'N/A' ? `${brand} ${model}` : model;
  return `${fullName} (${licensePlate})`;
};

// Calculer la progression
preparationSchema.methods.calculateProgress = function() {
  if (!this.steps || this.steps.length === 0) return 0;
  
  const completedSteps = this.steps.filter(step => step.completed).length;
  return Math.round((completedSteps / this.steps.length) * 100);
};

// V√©rifier si dans les temps
preparationSchema.methods.checkIfOnTime = function() {
  if (!this.currentDuration) return null;
  
  // Limite standard : 90 minutes
  const timeLimit = TIME_LIMITS[this.vehicleData?.vehicleType] || TIME_LIMITS.particulier;
  return this.currentDuration <= timeLimit;
};

// ===== M√âTHODES STATIQUES =====

// Trouver par plaque d'immatriculation (compatible ancien/nouveau)
preparationSchema.statics.findByLicensePlate = function(licensePlate) {
  const plateUpper = licensePlate.toUpperCase();
  
  return this.find({
    $or: [
      { 'vehicleData.licensePlate': plateUpper },
      { 'vehicleInfo.licensePlate': plateUpper } // Compatibilit√©
    ]
  }).populate(['user', 'agency', 'vehicle']);
};

// Trouver pr√©parations actives d'un utilisateur
preparationSchema.statics.findActiveByUser = function(userId) {
  return this.findOne({
    user: userId,
    status: { $in: [PREPARATION_STATUS.PENDING, PREPARATION_STATUS.IN_PROGRESS] }
  }).populate(['agency', 'vehicle']);
};

// ‚úÖ M√âTHODE SP√âCIALE POUR RAPPORT (√©vite les erreurs ObjectId)
preparationSchema.statics.findForReport = function(filters) {
  const query = this.find(filters)
    .populate('user', 'firstName lastName', null, { strictPopulate: false })
    .populate('agency', 'name code', null, { strictPopulate: false })
    .populate('vehicle', 'brand model licensePlate', null, { strictPopulate: false })
    .lean(); // ‚ö†Ô∏è IMPORTANT : .lean() √©vite les erreurs de cast
  
  return query;
};

// ===== VIRTUALS =====

preparationSchema.virtual('vehicleFullName').get(function() {
  return this.getVehicleFullName();
});

preparationSchema.virtual('isActive').get(function() {
  return [PREPARATION_STATUS.PENDING, PREPARATION_STATUS.IN_PROGRESS].includes(this.status);
});

module.exports = mongoose.model('Preparation', preparationSchema);